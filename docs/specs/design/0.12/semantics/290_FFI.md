# 290. Foreign Function Interface (FFI)

## 290.1 Overview

This chapter defines Ori’s **Foreign Function Interface (FFI)**.

Goals:
- Allow Ori code to call functions implemented in C (or C-compatible ABIs).
- Allow Ori code to interact with C-defined types and constants.
- Keep the FFI surface **minimal, explicit, and predictable**.
- Preserve Ori’s internal freedom to evolve layouts and ownership rules without being constrained by C ABI.

FFI in Ori is intentionally conservative. Only a small set of types are allowed across the boundary, and all extern declarations must be explicit about their ABI contracts.

Ori does **not** introduce any general attribute or annotation system for FFI.  
Instead, FFI uses the `extern` keyword as a compiler directive. See 280_CompilerDirectivesAndKeywords.md for the general description of `extern`.

---

## 290.2 Extern Declarations

Ori uses three FFI-specific declaration forms:

```ori
extern func ...
extern type struct ...
extern const ...
```

These forms are reserved for FFI usage only.

### 290.2.1 `extern func`

Declares a function that is implemented outside Ori, using the platform’s C ABI:
```ori
extern func memset(dst *uint8, value int32, size uint64) *void
extern func puts(s *int8) int32
extern func qsort(base *void, n uint64, size uint64, cmp *void) void
```

Rules:
- The declaration has **no body** in Ori.
- The function is assumed to follow the platform’s default C calling convention.
- All parameter and return types must be **FFI-safe** (see 290.3).
- The ABI and behavior are defined by the external implementation, not by Ori.

#### 290.2.1.1 Explicit Return Type Required

Every `extern func` must specify an explicit return type. The following is **forbidden**:
```ori
extern func foo()        // compile-time error: missing return type
```

If the C function returns `void`, the extern declaration must use:
```ori
extern func foo() void   // OK: explicit FFI void
```

This avoids ambiguity and keeps FFI contracts explicit.

### 290.2.2 `extern type struct`

Declares a struct type whose layout and ABI are defined externally (typically by C):

```ori
extern type Timeval struct {
    tv_sec  int64
    tv_usec int64
}

extern type File struct
```

There are two sub-kinds:
1. **Transparent FFI struct**: fields are declared in Ori and must use FFI-safe types.
2. **Opaque FFI struct**: no fields are declared; the type is only usable through pointers.

Rules:
- Layout is defined by the platform C ABI, not by Ori’s internal struct rules.
- Only **FFI-safe types** may be used as fields.
- `extern type struct` types:
  - Have trivial, POD-like semantics in Ori.
  - Do not participate in deterministic destruction (no destructors).
  - Cannot be generic.
  - Cannot define methods in Ori with a receiver of that type (see 290.6).

Opaque structs (no fields) are used as handles:

```ori
extern type File struct

extern func fopen(path *int8, mode *int8) *FILE
extern func fclose(f *FILE) int32
```

Ori cannot construct or inspect a value of an opaque extern struct; it can only pass pointers to and from external functions.

### 290.2.3 `extern const`

Declares a constant imported from an external library or object:
```ori
extern const EOF int32
extern const PI float64
```

Rules:
- The type must be FFI-safe.
- The value is provided by the external link target.
- The constant is read-only in Ori; assigning to it is a compile-time error.

---

## 290.3 FFI-Safe Types

An **FFI-safe type** is a type whose representation and ABI are guaranteed to match the C ABI used by the extern declarations.

The following types are FFI-safe:

### 290.3.1 Scalar Types

The following scalar types are allowed in `extern func` parameters and return positions, and as fields in `extern type struct`:
- `int8`, `int16`, `int32`, `int64`
- `uint8`, `uint16`, `uint32`, `uint64`
- `float32`, `float64`
- `bool` (mapped to C `_Bool` / `bool` according to the platform ABI)

For FFI, users should prefer these fixed-width types to maintain ABI clarity.

The following are **not FFI-safe** and forbidden in extern declarations or extern struct fields:

- `int`, `uint`, `float` (platform-dependent width)
- any future extended numeric types (e.g., big integers, decimals)
- any type aliases whose underlying type is not FFI-safe

### 290.3.2 Pointer and Array Types

The following pointer and array forms are FFI-safe:
- `*T` where `T` is FFI-safe
- `[N]T` where `T` is FFI-safe

Special case: `*void` is allowed **only in extern declarations** to model C’s `void*`:

```ori
extern func malloc(size uint64) *void
extern func free(ptr *void) void
```

Outside of extern declarations, `void` and `*void` are not used as general Ori types.

### 290.3.3 External Struct Types

`extern type struct` declarations define FFI-safe struct types.
- Transparent extern structs:
  - All fields must use FFI-safe types.
  - Copying a value is allowed and treated as a raw memory copy (no destructors).
- Opaque extern structs:
  - Have no fields declared in Ori.
  - Are only used through pointers.

If a non-FFI-safe type is used as a field in an `extern type struct`, the compiler must emit a compile-time error.

### 290.3.4 Non-FFI-Safe Types

The following kinds of types are **not FFI-safe** and cannot appear in `extern` declarations or `extern type struct` fields:
- string
- slices
- views
- maps, hashmaps, and any other managed containers
- sum types
- interfaces
- function types and closures
- generic types and generic instantiations
- any type that has a user-defined destructor or non-trivial deterministic destruction behavior

Using a non-FFI-safe type in an extern context is a compile-time error.

---

## 290.4 `void` in FFI

Ori does not use `void` as a general-purpose type in normal code.  
For native Ori functions, "no return value" is expressed as:

```ori
func log(msg string) {
    // ...
}
```

In FFI, `void` is introduced as a **pseudo-type** used only in extern declarations:

- As the return type of functions that return C `void`:
  ```ori
  extern func puts(s *int8) int32
  extern func free(ptr *void) void
  ```
- As `*void` to model C’s `void*` in extern declarations.

Rules:

- `void` is only valid in `extern func` declarations and as the pointee for `*void` in extern signatures.
- Declaring `var x void` or `var p *void` in normal Ori code is forbidden.
- `extern func` declarations must always specify an explicit return type; `extern func foo()` without a return type is a compile-time error.

---

## 290.5 Calling External Functions

Given an extern function declaration:

```ori
extern func write(fd int32, buf *uint8, n uint64) int64
```

Ori code may call it as a normal function:
```ori
func writeAll(fd int32, data []uint8) int64 {
    // assuming some way to obtain *uint8 and length from the slice
    var ptr = sliceDataPtr(data)
    var len = sliceLen(data)

    return write(fd, ptr, len)
}
```

Rules:

- The call syntax is the same as for normal Ori functions.
- The compiler assumes nothing about side effects or purity.
- If the external implementation has undefined behavior, that behavior is outside Ori’s semantics.

### 290.5.1 Pointer Validity for Calls

When passing a pointer to an extern function:

```ori
extern func takesPtr(p *int32) void

func example() {
    var x int32 = 42
    takesPtr(&x)       // OK
}
```

Rules:
- The value pointed to must remain valid for at least the duration of the call.
- It is a compile-time error to pass the address of a non-addressable temporary:
  ```ori
  takesPtr(&(1 + 2))   // compile-time error: temporary has no stable address
  ```
- Ori does not attempt to reason about the long-term storage behavior of the C function. The programmer must not allow C to store pointers to stack-allocated Ori data that will become invalid after the call returns.

---

## 290.6 Operations on `extern type struct`

For a transparent extern struct:

```ori
extern type Timeval struct {
    tv_sec  int64
    tv_usec int64
}
```

Allowed:
- Declaring variables:
  ```ori
  var tv Timeval
  ```
- Copying values (assignment uses raw memory copy semantics).
- Taking addresses (`&tv`) and passing `*Timeval` to extern functions.

Not allowed:
- Defining methods with receivers:
  ```ori
  extern type Timeval struct { tv_sec int64, tv_usec int64 }

  func (t *Timeval) ToMillis() int64 { ... }  // forbidden, compile-time error
  ```
- Defining destructors or participating in deterministic destruction.
- Using `extern type struct` as a generic parameter or instantiation.

For an opaque extern struct:
```ori
extern type File struct
```

- Values of type `FILE` cannot be constructed or copied in Ori.
- Only pointers (`*FILE`) may be used and passed to extern functions.

---

## 290.7 Ownership and Allocation Rules

FFI follows a conservative ownership model.

### 290.7.1 C-Owned Memory

Memory allocated by C (e.g., via `malloc`) is treated as **C-owned**:

```ori
extern func malloc(size uint64) *void
extern func free(ptr *void) void
```

Rules:
- Ori must not attempt to free, reallocate, or manage C-owned memory using Ori’s own allocators.
- The typical pattern is:
  - C allocates (`malloc`)  
  - Ori uses the pointer according to the API contract  
  - C frees (`free`)

---

### 290.7.2 Ori-Owned Memory

Memory allocated by Ori using its own allocation mechanisms is **Ori-owned**.

Rules:
- C must not attempt to free or reallocate Ori-owned memory using `free` or other C allocation functions.
- Ori is responsible for freeing its own allocations according to its ownership and deterministic destruction rules.

---

### 290.7.3 Passing Ori Pointers to C

When an Ori pointer is passed to C:

- The pointed-to memory must remain valid for the duration of the call.
- Ori code must not assume that C will obey Ori’s ownership conventions unless the API explicitly documents it.
- The compiler does not perform deep escape analysis across FFI; the programmer must avoid exposing stack-only or short-lived pointers to long-lived C data.

### 290.7.4 Returning Pointers from C to Ori

When C returns a pointer (e.g., from `malloc` or library APIs):

- Ori treats the pointer as opaque and does not attach ownership metadata.
- The contract for how to use and eventually free that pointer is defined by the external API documentation.
- Ori code must follow the external API’s rules (e.g., “free with `free`”, “do not free”, “use a specific destroy function”, etc.).

---

## 290.8 Forbidden Features in Extern Contexts

To keep the FFI small, predictable, and implementable, the following constructs are **not allowed** in extern declarations or extern type definitions:

- Generics:
  ```ori
  extern func foo[T](x T) void   // forbidden
  ```
- Methods with receivers:
  ```ori
  extern func (p *Point) Move()  // forbidden
  ```
- Interfaces and sum types.
- Slices, views, strings, maps, hashmaps, and any managed containers.
- Function types, closures, and callbacks (function pointers may be added in a future version).
- Any type with a user-defined destructor or non-trivial deterministic destruction behavior.

Use of these features in an extern context must produce a compile-time error.

---

## 290.9 Summary

- FFI uses `extern` as a keyword-based directive:
  - `extern func` for external functions.
  - `extern type struct` for external struct types (transparent or opaque).
  - `extern const` for external constants.
- All extern declarations must use **FFI-safe types** only.
- `void` is introduced solely as an FFI pseudo-type, primarily for return types and `*void` in extern signatures.
- `extern type struct` cleanly separates C-ABI types from Ori’s internal struct layout and deterministic destruction model.
- Ownership across FFI is conservative:
  - C-owned memory is freed by C.
  - Ori-owned memory is freed by Ori.
- Advanced language features (generics, methods, interfaces, containers, destructors) are excluded from the FFI surface to keep it small and predictable.

This specification provides a minimal but solid foundation for calling into C libraries and interoperating with C-defined types, while preserving Ori’s design goals of clarity, explicitness, and safety.
