# 001. OS Package â€” File System, Environment, and IO

The `os` package provides Ori's minimal, explicit, deterministic interface to the host operating system:
- opening, reading, writing, syncing, and closing files
- basic directory operations
- environment variables
- access to standard input, output, and error streams

This file defines the **API-level specification** for the `os` package.  
It is allowed to evolve in future versions, but must always respect the semantics described in:
- `semantics/370_FileSystemAndIO.md`
- `140_Errors.md`
- `220_DeterministicDestruction.md`
- `ecosystem/001_StandardLibraryFoundations.md`

---

## 001.1 Goals

- Provide a small, explicit API for working with the file system and environment
- Use value-typed, destructor-backed handles for OS resources.
- Integrate tightly with the builtin `Error` type
- Avoid any hidden buffering, background threads, or implicit concurrency
- Keep the API portable across platforms, while allowing platform-specific extensions in separate packages

This document describes the **complete OS API**.

---

## 001.2 Core Types

### 001.2.1 `File`

```ori
package os

type struct File {
    // internal representation is opaque and implementation-defined
}
```

`File` is an owning handle to an OS-backed file descriptor or equivalent. It has the following properties:
- **Ownership:** A `File` value owns exactly one OS resource. Ownership transfers when the value is moved
- **Move-only:** `File` cannot be copied implicitly. Cloning or copying a `File` is a compile-time error unless the language provides an explicit move operation
- **Destructor-backed:** When a `File` value goes out of scope, its destructor runs and performs a best-effort close of the underlying OS resource
- **Methods:** All methods that mutate internal state use a `shared` receiver:
  ```ori
  func (f shared File) Read(buf []byte) (int, Error)
  func (f shared File) Write(buf []byte) (int, Error)
  func (f shared File) Seek(offset int64, mode SeekMode) (int64, Error)
  func (f shared File) Sync() Error
  func (f shared File) Close() Error
  func (f shared File) Stat() (FileInfo, Error)
  func (f shared File) ReadAll() ([]byte, Error)
  func (f shared File) WriteAll(data []byte) Error
  ```

The internal layout (e.g. whether there is a raw `fd` integer) is not part of the API and may vary across implementations.

---

### 001.2.2 `FileMode`

```ori
type FileMode uint32
```

`FileMode` represents file permission bits and basic type information. The exact bit layout is implementation-defined, but must be sufficient to represent typical Unix-style permissions and basic type flags (directory, regular file, etc.).

The `os` package may expose portable constants, for example:

```ori
const ModePermUserRead  FileMode
const ModePermUserWrite FileMode
const ModePermUserExec  FileMode
// ... and so on for group/other
```

Additionally, examples may use octal notation (e.g. `0o755`) to describe typical Unix permissions.  
Ori does **not yet** support octal integer literals in the core language, but this notation is used in examples to indicate common Unix-style modes and anticipated future literal support (see `semantics/370_FileSystemAndIO.md`).

---

### 001.2.3 `FileInfo`

```ori
type struct FileInfo {
    Name const string     // base name, not a full path
    Size const int64      // size in bytes for regular files
    Mode const FileMode   // permission bits and basic type info
    IsDir const bool      // true if this represents a directory
    // Future fields (e.g. ModTime) may be added in later versions.
}
```

`FileInfo` is an immutable value providing metadata about a file system object.

---

### 001.2.4 `DirEntry`

```ori
type struct DirEntry {
    Name const string     // entry name, not a full path
    IsDir const bool      // true if the entry is a directory
    Mode const FileMode   // best-effort mode information
}
```

`DirEntry` is returned by directory listing APIs and does not own any OS resources.

---

### 001.2.5 `SeekMode`

```ori
type SeekMode int

const (
    SeekStart   SeekMode = 0  // relative to the beginning of the file
    SeekCurrent SeekMode = 1  // relative to the current offset
    SeekEnd     SeekMode = 2  // relative to the end of the file
)
```

`SeekMode` defines how the offset passed to `Seek` is interpreted.

---

### 001.2.6 `OpenOptions`

```ori
type struct OpenOptions {
    Read      bool
    Write     bool
    Append    bool
    Create    bool
    CreateNew bool
    Truncate  bool
    Mode      FileMode
}
```

`OpenOptions` allows precise control over how a file is opened. Invalid combinations (e.g. `CreateNew` without `Write`) must result in an `Error`.

---

## 001.3 Errors

All fallible functions and methods in the `os` package use the builtin `Error` type as their last return value.

The `os` package may define sentinel errors for common conditions:

```ori
const ErrNotFound         Error
const ErrPermissionDenied Error
const ErrAlreadyExists    Error
const ErrIsDir            Error
const ErrInvalidPath      Error
const ErrInvalidSeek      Error
const ErrClosed           Error
const ErrEOF              Error
```

These sentinel values must be comparable using `==` and have stable `Code` fields within a given Ori version.

Example:

```ori
var file, err = os.Open("config.toml")
if err == ErrNotFound {
    // handle missing file
}
```

---

## 001.4 File Operations

### 001.4.1 Opening files

```ori
func os.Open(path string) (File, Error)
```

- Opens an existing file at `path` in read-only mode
- Returns `(File, nil)` on success
- Returns `(File{}, ErrNotFound)` if the file does not exist

```ori
func os.Create(path string) (File, Error)
```

- Creates or truncates the file at `path` for read/write access.
- Returns `(File, nil)` on success
- Returns an appropriate `Error` on failure (e.g. `ErrInvalidPath`, `ErrPermissionDenied`)

```ori
func os.OpenWith(path string, opts OpenOptions) (File, Error)
```

- Opens a file with the specified options
- Must reject invalid combinations of options with a clear `Error` (e.g. `ErrInvalidPath` or another sentinel)

### 001.4.2 Reading

```ori
func (f shared File) Read(buf []byte) (int, Error)
```

- Attempts to read up to `len(buf)` bytes into `buf`
- Returns `(n, nil)` on success (`0 <= n <= len(buf)`)
- At end-of-file:
  - Returns `(0, ErrEOF)` if no bytes were read
  - May return `(n > 0, nil)` and report EOF on the next call
- Returns `(0, ErrClosed)` if the file is closed

```ori
func (f shared File) ReadAll() ([]byte, Error)
```

- Reads from the current offset until EOF
- Allocates and returns a new `[]byte` slice containing the entire content
- Returns `ErrClosed` if the file is closed

### 001.4.3 Writing

```ori
func (f shared File) Write(buf []byte) (int, Error)
```

- Attempts to write up to `len(buf)` bytes from `buf` into the file
- May return partial writes (`n < len(buf)`) without error, depending on OS behavior
- Returns `(n, ErrClosed)` if the file is closed

```ori
func (f shared File) WriteAll(data []byte) Error
```

- Writes all bytes from `data`, repeatedly calling `Write` until completion or error
- Returns `nil` on success, or a non-`nil` `Error` on failure

### 001.4.4 Seeking

```ori
func (f shared File) Seek(offset int64, mode SeekMode) (int64, Error)
```

- Repositions the file offset based on `offset` and `mode`
- Returns the new absolute offset from the beginning of the file
- Returns `ErrInvalidSeek` if the resulting offset would be negative or otherwise invalid
- Returns `ErrClosed` if the file is closed

### 001.4.5 Syncing

```ori
func (f shared File) Sync() Error
```

- Flushes in-memory state of the file to stable storage, as far as the platform allows.
- Returns `nil` on success or an appropriate `Error` on failure.
- Returns `ErrClosed` if the file is closed.

### 001.4.6 Closing

```ori
func (f shared File) Close() Error
```

- Closes the underlying OS resource and marks the `File` as closed
- Returns `nil` on success
- Returns `ErrClosed` if the file is already closed
- After `Close()` succeeds:
  - The destructor for `File` becomes a no-op for that value
  - All subsequent calls to `Read`, `Write`, `Seek`, `Sync`, and `Stat` return `ErrClosed`

If user code never calls `Close()`, the `File` destructor will still close the resource best-effort, but any close error is ignored, as required by the semantics document.

### 001.4.7 Metadata

```ori
func (f shared File) Stat() (FileInfo, Error)
func os.Stat(path string) (FileInfo, Error)
```

- `File.Stat` returns metadata for the open file described by `f`
- `os.Stat` returns metadata for the file system object at `path` without opening it for IO
- Both return `(FileInfo{}, ErrNotFound)` if the target does not exist

---

## 001.5 Directory Operations

### 001.5.1 Creating directories

```ori
func os.Mkdir(path string, mode FileMode) Error
```

- Creates a single directory at `path` with the specified `mode`
- Returns `ErrAlreadyExists` if a file or directory already exists at `path`
- Returns `ErrInvalidPath` for invalid paths
- Returns `ErrPermissionDenied` for permission errors

Examples may use octal-like notation for the mode, such as:

```ori
var err = os.Mkdir("data", 0o755)
// NOTE: 0o755 is illustrative and may rely on future octal literal support.
```

### 001.5.2 Removing files and directories

```ori
func os.Remove(path string) Error
```

- Removes the file or empty directory at `path`
- Returns `ErrNotFound` if `path` does not exist
- Returns `ErrPermissionDenied` or another appropriate `Error` if removal fails

Higher-level helpers such as `RemoveAll` may be added later, but are not part of current spec.

### 001.5.3 Listing directory contents

```ori
func os.ReadDir(path string) ([]DirEntry, Error)
```

- Returns a slice of `DirEntry` for the immediate entries in the directory at `path`
- Whether `.` and `..` are included is implementation-defined, but implementations are encouraged to exclude them
- Returns `ErrNotFound` if the directory does not exist
- Returns `ErrPermissionDenied` if the directory cannot be read

This is a collect-all API meant for typical use cases and small to medium directories.

---

## 001.6 Environment Variables

The `os` package exposes environment variables as process-level key-value pairs.

```ori
func os.Getenv(key string) (string, bool)
```

- Returns the value associated with `key` and a boolean indicating whether the variable is set
- Returns `("", false)` if the variable is not set

```ori
func os.Setenv(key string, value string) Error
```

- Sets the environment variable `key` to `value`
- Returns `nil` on success or an appropriate `Error` on failure

```ori
func os.Unsetenv(key string) Error
```

- Removes the environment variable `key` from the environment
- Returns `nil` on success, even if the variable was not previously set
- Returns an appropriate `Error` on failure

All environment functions must be safe to call from multiple concurrent tasks.

---

## 001.7 Standard Streams

The process-wide standard streams are exposed via three functions:

```ori
func os.Stdin() File
func os.Stdout() File
func os.Stderr() File
```

Each call returns a `File` value that acts as a **non-owning wrapper** around the corresponding process stream:

- The underlying OS descriptors for standard input, output, and error are **not** owned by these `File` values for the purposes of destruction
- The destructor for these wrapper values must not attempt to close the real OS standard streams
- The `Close()` method on such wrapper values:
  - must **not** close the real OS stream; and
  - should either return `ErrInvalidOperation` or be explicitly documented as a no-op

All other methods (`Read` on `os.Stdin()`, `Write` / `WriteAll` on `os.Stdout()` and `os.Stderr()`, etc.) behave as for regular `File` values, subject to OS constraints.

Typical usage:

```ori
import "os"

func main() {
    var out = os.Stdout()
    out.WriteAll([]byte("hello, world
"))
}
```

The implementation is free to cache underlying OS handles internally, but such details are not visible at the API level.

---

## 001.8 Concurrency Behavior

- All `os` file and directory operations are **blocking** from the perspective of the calling task
- The `File` type is **not guaranteed** to be safe for concurrent use from multiple tasks without synchronization
- Implementations may document certain operations as thread-safe, but users must not rely on implicit safety

To share a `File` between tasks, user code should wrap it in a synchronization primitive such as a mutex.

Destructors for `File` must obey the global rules:

- no panics
- no unbounded blocking
- single best-effort close

---

## 001.9 Octal File Modes in Examples

This document uses octal notation for file modes in examples, such as:
```ori
os.Mkdir("logs", 0o755)
```

Ori does **not yet** support octal integer literals in the language, but:
- this notation reflects a widely-used Unix/Linux convention for file permissions;
- future versions of Ori are expected to support octal literals (e.g. via a `0o` prefix)
- until then, such examples should be treated as **conceptual** and may rely on tooling or compiler flags in early implementations

Implementations targeting Unix-like systems should ensure that `FileMode` and mode-related APIs behave consistently with this conceptual model, even if the literal syntax evolves later.

---

## 001.10 Examples

### 001.10.1 Copying a file

```ori
import "os"

func CopyFile(srcPath string, dstPath string) Error {
    var src, err = os.Open(srcPath)
    if err != nil {
        return err
    }
    defer src.Close()

    var dst, err2 = os.Create(dstPath)
    if err2 != nil {
        return err2
    }
    defer dst.Close()

    var buf = make([]byte, 4096)
    for {
        var n, rerr = src.Read(buf)
        if rerr == ErrEOF {
            break
        }
        if rerr != nil {
            return rerr
        }

        var written = 0
        while written < n {
            var w, werr = dst.Write(buf[written:n])
            if werr != nil {
                return werr
            }
            written += w
        }
    }

    return nil
}
```

### 001.10.2 Reading a small configuration file

```ori
import "os"

func ReadConfig(path string) ([]byte, Error) {
    return os.ReadFile(path)
}
```

### 001.10.3 Creating a directory and listing contents

```ori
import "os"

func ListOrCreateDir(path string) Error {
    var err = os.Mkdir(path, 0o755)
    if err != nil && err != ErrAlreadyExists {
        return err
    }

    var entries, derr = os.ReadDir(path)
    if derr != nil {
        return derr
    }

    for _, e := range entries {
        if e.IsDir {
            println("dir ", e.Name)
        } else {
            println("file", e.Name)
        }
    }

    return nil
}
```

This concludes the current specification of the `os` package's file system, environment, and standard stream APIs.
